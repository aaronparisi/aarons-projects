import { Component } from 'react';
import PropTypes from 'prop-types';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var STAGGER_GROUP_WINDOW = 100;

var StaggerTiming = function () {
  function StaggerTiming() {
    classCallCheck(this, StaggerTiming);
    this.lastStagger = 0;
    this.currentDelay = 0;
    this.lastDelay = 0;
  }

  StaggerTiming.prototype.getDelay = function getDelay(newDelay, commitDelay) {
    var now = Date.now();
    newDelay = +newDelay;
    if (now - this.lastStagger > STAGGER_GROUP_WINDOW) {
      this.lastStagger = now;
      this.currentDelay = 0;
      this.lastDelay = 0;
    }

    if (this.currentDelay > 0 || this.lastDelay > 0) {
      this.lastDelay = Math.max(this.lastDelay, newDelay);
    }

    var delay = this.currentDelay + this.lastDelay;
    if (commitDelay) {
      this.currentDelay += this.lastDelay;
      this.lastDelay = newDelay;
    }
    return delay;
  };

  return StaggerTiming;
}();

var globalTiming = new StaggerTiming();

var Stagger = function (_Component) {
  inherits(Stagger, _Component);

  function Stagger() {
    var _temp, _this, _ret;

    classCallCheck(this, Stagger);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.staggerContext = {
      subscribe: _this.subscribe.bind(_this),
      value: false,
      timing: _this.props.timing || _this.context.timing || globalTiming
    }, _this.selfValue = _this.props.in, _this.subscribers = [], _this.unsubscribe = null, _this.state = {
      value: false,
      delay: 0
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Stagger.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    if (this.context.stagger) {
      this.unsubscribe = this.context.stagger.subscribe(function () {
        return _this2.checkUpdate();
      });
    }
    if (!this.props.appear) {
      this.checkUpdate(true);
    }
  };

  Stagger.prototype.componentDidMount = function componentDidMount() {
    if (this.props.appear) {
      this.checkUpdate();
    }
  };

  Stagger.prototype.componentWillReceiveProps = function componentWillReceiveProps(newProps) {
    this.selfValue = newProps.in;
    this.checkUpdate();
  };

  Stagger.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  };

  Stagger.prototype.checkUpdate = function checkUpdate(forceInstant) {
    // Only stagger if self and all parents are active.
    var parentValue = this.context.stagger ? this.context.stagger.value : true;
    var value = this.selfValue && parentValue;

    // Only continue if the value has changed.
    if (value === this.staggerContext.value) {
      return;
    }

    this.staggerContext.value = value;

    var delay = this.calculateDelay(value, forceInstant);
    this.setState({
      value: value,
      delay: delay
    });
  };

  Stagger.prototype.calculateDelay = function calculateDelay(value, forceInstant) {
    // Get delay for self. Note, the actual delay is max of all stagger
    // delays since last leaf stagger.
    // stagger(300)    - 0
    //   stagger(100)  - 0
    //   stagger(100)  - 100
    //   stagger(100)  - 200
    // stagger(200)    - 400
    //   stagger(100)  - 400
    // stagger(500)    - 900

    if (forceInstant) {
      return 0;
    }

    var timing = this.staggerContext.timing;
    var isLeaf = !this.subscribers.length;

    var _getOwnDelay = this.getOwnDelay(),
        beforeDelay = _getOwnDelay[0],
        afterDelay = _getOwnDelay[1];

    // Add delay for self and get total delay since last leaf.


    var totalDelay = value ? timing.getDelay(beforeDelay, isLeaf) : 0;

    if (!isLeaf) {
      // Notify children of change.
      this.subscribers.forEach(function (subscriber) {
        subscriber();
      });
    }

    // Add delay after children.
    if (value) {
      timing.getDelay(afterDelay, false);
    }

    return totalDelay;
  };

  Stagger.prototype.getOwnDelay = function getOwnDelay() {
    var delay = this.props.delay;

    return Array.isArray(delay) ? delay : [delay, delay];
  };

  Stagger.prototype.getChildContext = function getChildContext() {
    return {
      stagger: this.staggerContext
    };
  };

  Stagger.prototype.subscribe = function subscribe(handler) {
    var _this3 = this;

    this.subscribers.push(handler);
    return function () {
      _this3.subscribers = _this3.subscribers.filter(function (h) {
        return h !== handler;
      });
    };
  };

  Stagger.prototype.render = function render() {
    var children = this.props.children;

    if (typeof children === 'function') {
      return children(this.state);
    }
    return children || null;
  };

  return Stagger;
}(Component);

Stagger.childContextTypes = {
  stagger: PropTypes.object.isRequired
};
Stagger.contextTypes = {
  stagger: PropTypes.object
};
Stagger.defaultProps = {
  delay: 100,
  in: true,
  appear: true
};
process.env.NODE_ENV !== "production" ? Stagger.propTypes = {
  timing: PropTypes.instanceOf(StaggerTiming),
  delay: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),
  in: PropTypes.bool,
  appear: PropTypes.bool,
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func])
} : void 0;

export default Stagger;
